#pragma once
#include "common.cpp"
using namespace dalt;
#include "topo_sort.cpp"

void SolveOne(int test_id, IStream &in, OStream &out) {
  int H, W;
  in >> H >> W;
  Vec<Vec<int>> A(H, Vec<int>(W));
  Vec<Vec<int>> B(W, Vec<int>(H));
  in >> A;
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      B[j][i] = A[i][j];
    }
  }
  var check = [&](const Vec<Vec<int>> &A) {
    int H = Size(A);
    int W = Size(A[0]);
    using namespace graph;
    using E = DiBaseEdge;
    Graph<E> g(H * W + W);
    var id_of_col = [&](int c) { return c; };
    var id_of_ps = [&](int r, int c) { return r * W + c + W; };

    for (int r = 0; r < H; r++) {
      Vec<int> idx;
      for (int i = 0; i < W; i++) {
        if (i > 0) {
          AddDiEdge(g, id_of_ps(r, i), id_of_ps(r, i - 1));
        }
        if (A[r][i] != 0) {
          idx.push_back(i);
        }
      }
      Sort(All(idx), [&](int i, int j) { return A[r][i] < A[r][j]; });
      int last_offset = 0;
      for (int c = 0; c < Size(idx); c++) {
        while (last_offset < Size(idx) &&
               A[r][idx[last_offset]] < A[r][idx[c]]) {
          last_offset++;
        }
        AddDiEdge(g, id_of_ps(r, c), id_of_col(idx[c]));
        if (last_offset > 0) {
          AddDiEdge(g, id_of_col(idx[c]), id_of_ps(r, last_offset - 1));
        }
      }
    }
    var topo = TopoSort(g);
    return topo.is_some();
  };
  if (check(B)) {
    out << "Yes";
  } else {
    out << "No";
  }
}

void SolveMulti(IStream &in, OStream &out) {
  // std::ifstream input("in");
  int num_of_input = 1;
  // in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    // SolveOne(i + 1, input, out);
    SolveOne(i + 1, in, out);
  }
}