#pragma once
#include "common.cpp"
using namespace dalt;
#include "math.cpp"
void SolveOne(int test_id, IStream &in, OStream &out) {
  i64 B, K, Sx, Sy, Gx, Gy;
  in >> B >> K >> Sx >> Sy >> Gx >> Gy;
  using Pt = Array<i64, 2>;
  var around = [&](Pt pt) {
    Vec<Pt> Ss;
    var Sx = pt[0];
    var Sy = pt[1];
    Ss.push_back(Pt {Sx / B * B, Sy});
    Ss.push_back(Pt {Sx / B * B + B, Sy});
    Ss.push_back(Pt {Sx, Sy / B * B});
    Ss.push_back(Pt {Sx, Sy / B * B + B});
    return Ss;
  };
  Vec<Pt> Ss = around(Pt {Sx, Sy});
  Vec<Pt> Gs = around(Pt {Gx, Gy});
  Pt start = Pt{Sx, Sy};
  Pt end = Pt{Gx, Gy};
  var dist = [&](Pt& a, Pt& b) {
    return Abs(a[0] - b[0]) + Abs(a[1] - b[1]); 
  };
  var dist2 = [&](Pt a, Pt b) {
    if(a[1] % B != 0) {
      Swap(a[0], a[1]);
      Swap(b[0], b[1]);
    }
    if(a[1] == b[1]) {
      return dist(a, b);
    }
    var e1 = Pt{a[0] / B * B, a[1]};
    var e2 = Pt{a[0] / B * B + B, a[1]};
    return Min(dist(e1, a) + dist(e1, b), dist(e2, a) + dist(e2, b));
  };
  i64 ans = dist(start, end) * K;
  for(var &a : Ss) {
    for(var &b : Gs) {
      Chmin(ans, dist(start, a) * K + dist2(a, b) + dist(b, end) * K);
    }
  }
  out << ans << '\n';
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}