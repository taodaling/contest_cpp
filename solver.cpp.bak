#pragma once
#include "common.cpp"
using namespace dalt;
#include "int128.cpp"
#include "radix.cpp"
using Bi = int128_t;
struct Item {
  Bi value;
  bool used;
  i64 w;
  i64 p;
};
struct Event {
  int index;
  Bi value;
  Bi bonus;
  i64 w;
  i64 p;
};

void SolveOne(int test_id, IStream &in, OStream &out) {
  int n, k;
  i64 _mxw, _mxp, _a, _b;
  Bi mxw, mxp, a, b;
  in >> n >> k >> _mxw >> _mxp >> _a >> _b;
  mxw = _mxw;
  mxp = _mxp;
  a = _a;
  b = _b;
  Debug(mxw);
  Debug(mxp);
  Debug(a);
  Debug(b);
  a *= 100;
  Debug(a);
  Vec<Item> items(n);
  Vec<Event> events;
  var eval = [&](Bi w, Bi p) {
    Bi ans = 0;
    if(w > mxw) {
      ans += (w - mxw) * a;
    }
    if(p > mxp) {
      ans += (p - mxp) * b;
    }
    return ans;
  };
  Radix<i64> radix(10);
  var maximize = [&](var& dfs, i64 x, int digit, bool start) {
    if(digit < 0) {
      return x;
    }
    var value = radix.get(x, digit);
    if(!start && value == 0) {
      return dfs(dfs, x, digit - 1, false);
    }
    if(value == 9) {
      return dfs(dfs, x, digit - 1, true);
    }
    return radix.set(x, digit, 9);
  };
  for(int i = 0; i < n; i++) {
    i64 w, p;
    in >> w >> p;
    i64 mw = maximize(maximize, w, 10, false);
    i64 mp = maximize(maximize, p, 10, false);
    Debug(p);
    Debug(mp);
    Debug(w);
    Debug(mw);
    items[i].p = p;
    items[i].w = w;
    items[i].value = eval(w, p);
    items[i].used = false;
    events.push_back(Event{});
    events.back().index = i;
    events.back().p = mp;
    events.back().w = w;
    events.back().value = eval(w, mp);
    events.back().bonus = events.back().value - items[i].value;
    events.push_back(Event{});
    events.back().index = i;
    events.back().p = p;
    events.back().w = mw;
    events.back().value = eval(mw, p);
    events.back().bonus = events.back().value - items[i].value;
  }
  Sort(All(events), [&](auto &a, auto &b) { return a.bonus > b.bonus; });
  int remain_chance = k;
  for(int i = 0; remain_chance > 0; i++) {
    var &e = events[i];
    if(items[e.index].used) {
      continue;
    }
    Debug(e.index);
    Debug(e.bonus);
    Debug(e.value);
    remain_chance--;
    items[e.index].used = true;
    items[e.index].p = e.p;
    items[e.index].w = e.w;
    items[e.index].value = e.value;
  }
  Bi sum = 0;
  for(int i = 0; i < n; i++) {
    sum += items[i].value;
  }
  Debug(sum);
  out << (sum / 100) << "." << (sum / 10 % 10) << (sum % 10) << '\n';
  for(int i = 0; i < n; i++) {
    out << items[i].w << ' ' << items[i].p << '\n';
  }
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}