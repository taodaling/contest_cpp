#pragma once
#include "common.cpp"
using namespace dalt;
#include "ac_automaton.cpp"


void SolveOne(int test_id, IStream &in, OStream &out) {
  Str S;
  int N;
  in >> S >> N;
#ifdef LOCAL
  seq::ACAutomaton<> ac((int)1e2);
#else
  seq::ACAutomaton<> ac((int)1e6);
#endif
  Vec<int> ids(N);
  for(int i = 0; i < N; i++) {
    Str T;
    in >> T;
    var builder = ac.builder();
    for(var c : T) {
      builder.build(c - 'a');
    }
    ids[i] = builder.build_last;
  }
  var topo = ac.topo_sort();
  Vec<bool> invalid(Size(topo));
  for(var id : ids) {
    invalid[id] = true;
  }
  Debug(ac.fails);
  for(int i = 0; i < Size(topo); i++) {
    Debug(i);
    Debug(ac.debug_node(i));
  }
  Debug(topo);
  for(int i : topo) {
    if(ac.fails[i] != -1) {
      invalid[i] = invalid[i] || invalid[ac.fails[i]];
    }
  }
  Debug(ids);
  Debug(invalid);
  var matcher = ac.matcher();
  int change = 0;
  for(char c : S) {
    matcher.match(c - 'a');
    Debug(matcher.match_last);
    Debug(ac.debug_node(matcher.match_last));
    if(invalid[matcher.match_last]) {
      change++;
      matcher = ac.matcher();
    }
  }

  out << change;
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}