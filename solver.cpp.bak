#pragma once
#include "common.cpp"
using namespace dalt;
<<<<<<< HEAD
#include "cartesian_tree.cpp"
#include "binary_search.cpp"
void SolveOne(int test_id, IStream &in, OStream &out) {
  int N, Q;
  in >> N >> Q;
  Vec<int> P(N);
  Vec<int> A(N);
  in >> P >> A;
  int K = 0;
  for(int a : A) {
    K += a == 0;
  }
  Vec<int> S(K - 1);
  in >> S;
  using Node = CartesianTree;
  Node *root = Node::from(N, [&](int a, int b) {return P[a] > P[b];});
  bool ok = true;
  Vec<Pair<int, int>> intervals;
  var dfs = [&](var &dfs, Node *root, int max_from_ancestor) -> int {
    if(root == NULL) {
      return 0;
    }
    int index = root->index;
    if(A[index] > 0) {
      if(max_from_ancestor <= A[index]) {
        ok = false;
      }
      max_from_ancestor = A[index];
    }
    int left = dfs(dfs, root->left, max_from_ancestor);
    int right = dfs(dfs, root->right, max_from_ancestor);
    int max_from_children = Max(left, right);
    if(A[index] > 0) {
      if(max_from_children >= A[index]) {
        ok = false;
      }
      max_from_children = A[index];
    } else {
      intervals.push_back(MakePair(max_from_children, max_from_ancestor));
    }
    return max_from_children;
  };
  MakeUniqueAndSort(S);
  ok = ok && Size(S) == K - 1;
  Sort(All(intervals), [&](var &a, var &b) {
    return a.second < b.second;
  });
  var try_solution = [&](Vec<int> pts, Vec<Pair<int, int>> intervals, bool chance) -> Pair<int, int> {
    Pair<int, int> ans(0, 1e9);
    MultiTreeSet<int> pts_set;
    for(var x : pts) {
      pts_set.insert(x);
    }
    for(var &interval : intervals) {
      var iter = pts_set.lower_bound(interval.first + 1);
      if(iter == pts_set.end() || *iter >= interval.second) {
        if(chance) {
          chance = false;
          ans = interval;
        } else {
          return MakePair(0, -1);
        }
      } else {
        pts_set.erase(iter);
      }
    }
    return ans;
  };
  var extra = try_solution(S, intervals, true);
  if(extra.first > extra.second) {
    ok = false;
=======

void SolveOne(int test_id, IStream &in, OStream &out) {
  int N;
  in >> N;
  Vec<int> P(N);
  Vec<int> I(N);
  in >> P >> I;
  P -= 1;
  I -= 1;
  Vec<int> loc_in_I(N);
  for(int i = 0; i < N; i++) {
    loc_in_I[I[i]] = i;
  }
  Vec<Pair<int, int>> tree(N, MakePair(-1, -1));
  bool ok = true;
  var dfs = [&](var &dfs, int l, int r, int L, int R) {
    
    if(r - l != R - L) {
      ok = false;
      return -1;
    }
    if(l > r) {
      return -1;
    }
    if(l == r) {
      if(P[l] != I[L]) {
        ok = false;
      }
      DebugFmtln("root = %d, l = %d, r = %d, L = %d, R = %d", P[l] + 1, l, r, L,
                 R);
      return P[l];
    }
    int root = P[l];
    int root_in_I = loc_in_I[root];
    if(root_in_I < L || root_in_I > R) {
      ok = false;
      return -1;
    }
    int left_size = root_in_I - L;
    tree[root].first = dfs(dfs, l + 1, l + 1 + left_size - 1, L, root_in_I - 1);
    tree[root].second = dfs(dfs, l + 1 + left_size, r, root_in_I + 1, R);
    DebugFmtln("root = %d, l = %d, r = %d, L = %d, R = %d", root + 1, l, r, L, R);
    return root;
  };
  int root = dfs(dfs, 0, N - 1, 0, N - 1);
  if(root != 0) {
    ok = false;
  }
  if(!ok) {
    out << -1;
    return;
  }
  for(int i = 0; i < N; i++) {
    out << tree[i].first + 1 << ' ' << tree[i].second + 1 << '\n';
>>>>>>> b46946b732639960913f85db39716635a2b19ba2
  }
  Pair<int, int> range(-1, -1);
  if(ok) {
    var checker = [&](int M) {
      Vec<int> data;
      data.reserve(K);
      data.insert(data.end(), All(S));
      data.push_back(M);
      var ans = try_solution(data, intervals, false);
      return ans.first <= ans.second;
    };
    int L = FirstTrue<int>(0, extra.first + 1, checker);
    int R = LastTrue<int>(extra.second - 1, (int)1e6, checker);
    range = MakePair(L, R);
  }
  
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}