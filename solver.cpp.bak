#pragma once
#include "common.cpp"
using namespace dalt;
#include "maxflow.cpp"

void SolveOne(int test_id, IStream &in, OStream &out) {
  int H, W;
  in >> H >> W;
  Vec<Vec<int>> cost(H, Vec<int>(W));
  in >> cost;
  using namespace graph;
  using E = FlowBaseEdge<i64>;
  var id_row = [&](int i) {
    return i;
  };
  var id_col = [&](int i) {
    return H + i;
  };
  var id_src = [&]() {
    return H + W;
  };
  var id_dst = [&]() {
    return id_src() + 1;
  };
  Graph<E> g(id_dst() + 1);
  i64 total = 0;
  for(int i = 0; i < H; i++) {
    i64 sum = 0;
    for(var x : cost[i]) {
      sum += x;
    }
    sum = Max<i64>(0, sum);
    total += sum;
    AddFlowEdge(g, id_src(), id_row(i), sum);
  }
  for(int i = 0; i < W; i++) {
    i64 sum = 0;
    for(int j = 0; j < H; j++) {
      sum += cost[j][i];
    }
    sum = Max<i64>(0, sum);
    total += sum;
    AddFlowEdge(g, id_col(i), id_dst(), sum);
  }
  i64 inf = 1e18;
  for(int i = 0; i < H; i++) {
    for(int j = 0; j < W; j++) {
      i64 val = cost[i][j];
      if(val < 0) {
        val = inf;
      }
      AddFlowEdge(g, id_row(i), id_col(j), val);
    }
  }
  var min_cut = MaxFlowDinic(g, id_src(), id_dst(), inf);
  i64 ans = total - min_cut;
  out << ans << '\n';
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}