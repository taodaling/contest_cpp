#pragma once
#include "common.cpp"
using namespace dalt;
#include "segtree.cpp"
 
void SolveOne(int test_id, IStream &in, OStream &out) {
  const int BIT = 30;
  using A3 = Array<int, 3>;
  using A2 = Array<int, 2>;
  using SBT = sbt::SelfBalanceTreeRegistry<A3, A2>;
  using ST = sbt::SegTree<SBT, false, true>;
  int inf = 1 << BIT;
  ST::Register(A3{inf, -1, 0}, A2 {0, 0}, 
  [&](var a, var b) {
    int val = Min(a[0], b[0]);
    if(a[2] > 0 && b[2] > 0) {
      val = Min(val, a[1] ^ b[1]);
    }
    return A3 {val, Max(a[1], b[1]), a[2] + b[2]};
  }, 
  [&](var a, var b) {
    if(b[1] == 0) {
      return a;
    }
    if(a[2] + b[1] == 0) {
      return A3 {inf, -1, 0};
    }
    if(a[2] + b[1] == 1) {
      return A3 {inf, b[0], a[2] + b[1]};
    }
    return A3 {0, b[0], a[2] + b[1]};
  },
  [&](var a, var b) {
    return A2 {a[0], a[1] + b[1]};
  });

  ST st = ST::MakeSparseTree(inf);
  int Q;
  in >> Q;
  for(int i = 0; i < Q; i++) {
    int t;
    in >> t;
    if(t == 1) {
      int x;
      in >> x;
      st.update(x, x, A2 {x, 1});
    } else if(t == 2) {
      int x;
      in >> x;
      st.update(x, x, A2 {x, -1});
    } else {
      var ans = st.query_const(0, inf - 1);
      out << ans[0] << '\n';
    }
  }
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}