#pragma once
#include "common.cpp"
using namespace dalt;
#include "bipartite_match.cpp"
void SolveOne(int test_id, IStream &in, OStream &out) {
  int H, W;
  in >> H >> W;
  Vec<String> mat(H);
  in >> mat;
  using namespace graph;
  using E = BiBaseEdge;
  Graph<E> g(H * W * 2);
  var id_of = [&](int i, int j) { return i * W + j; };
  int dirs[][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      char c = mat[i][j];
      if (c == '2') {
        // add edge
        for (var &d : dirs) {
          int ni = i + d[0];
          int nj = j + d[1];
          if (ni < 0 || ni >= H || nj < 0 || nj >= W) continue;
          if (mat[ni][nj] == '2') {
            AddBiEdge(g, id_of(i, j), id_of(ni, nj));
          }
        }
      } else if (c == '?') {
        // AddBiEdge(g, id_of_left(i, j), id_of_left(i, j));
      }
    }
  }
  var mate = BipartiteMatch(g, false, Vec<int>(), H * W);
  Debug(mate);
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      char c = mat[i][j];
      if (c == '2') {
        // add edge
        for (var &d : dirs) {
          int ni = i + d[0];
          int nj = j + d[1];
          if (ni < 0 || ni >= H || nj < 0 || nj >= W) continue;
          if (mat[ni][nj] == '?') {
            AddBiEdge(g, id_of(i, j), id_of(ni, nj) + H * W);
          }
        }
      } else if (c == '?') {
        // AddBiEdge(g, id_of_left(i, j), id_of_left(i, j));
      }
    }
  }
  mate = BipartiteMatch(g, false, Move(mate), H * W);
  Debug(mate);
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      if (mat[i][j] == '2') {
        int id = id_of(i, j);
        if (mate[id] == -1) {
          out << "No";
          return;
        }
      }
    }
  }
  out << "Yes";
}

void SolveMulti(IStream &in, OStream &out) {
  // std::ifstream input("in");
  int num_of_input = 1;
  // in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    // SolveOne(i + 1, input, out);
    SolveOne(i + 1, in, out);
  }
}