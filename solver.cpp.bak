#pragma once
#include "common.cpp"
using namespace dalt;
#include "binary_search.cpp"
#include "limit_value.cpp"
void SolveOne(int test_id, IStream &in, OStream &out) {
  int N;
  i64 H;
  in >> N >> H;
  struct Spell {
    i64 t;
    i64 d;
  };
  Vec<Spell> spells(N);
  for(int i = 0; i < N; i++) {
    in >> spells[i].t >> spells[i].d;
  }
  Sort(All(spells), [&](var &a, var &b) {
    return MakePair(a.d, a.t) < MakePair(b.d, b.t);
  });
  Reverse(All(spells));
  Vec<Pair<i64, Spell>> phase;
  i64 inf = 1e18;
  var cross_time = [&](const_ref(Spell) a, const_ref(Spell) b) -> i64 {
    if(a.d == b.d) {
      return inf;
    }
    //b.t >= t > a.t
    //a.d * a.t < b.d * t
    i64 t = (a.d * a.t + b.d - 1) / b.d;
    if(t > b.t) {
      return inf;
    }
    return t;
  };
  for(var &spell : spells) {
    bool insert = false;
    while(!phase.empty()) {
      var &back = phase.back();
      if(back.second.d == spell.d) {
        insert = true;
        break;
      }
      var t = cross_time(back.second, spell);
      if(t <= back.first) {
        phase.pop_back();
        continue;
      }
      insert = true;
      if(t < inf) {
        phase.emplace_back(t, spell);
      }
      break;
    }
    if(!insert) {
      phase.emplace_back(0, spell);
    }
  }
  var interval = [&](i64 l, i64 r, i64 L, i64 R) {
    Chmax(l, L);
    Chmin(r, R);
    i64 ans = r - l + 1;
    Chmax(ans, 0);
    return ans;
  };
  using LM = LimitValue<i64>;
  var sum = [&](i64 l, i64 r) {
    var each = (l + r);
    var round = (r - l + 1);
    if(each % 2 == 0) {
      each /= 2;
    } else {
      round /= 2;
    }
    return LM(each) * round;
  };
  var checker = [&](i64 t) -> bool {
    LM ans = 0;
    for(int i = 0; i < Size(phase); i++) {
      i64 L = phase[i].first;
      i64 next = i == Size(phase) - 1 ? t + 1 : phase[i + 1].first;
      i64 R = next - 1;
      Chmin(R, t);
      if(L > R) {
        continue;
      }
      //begin ... end
      LM contrib = 0;
      contrib += LM(interval(L, R, phase[i].second.t, inf)) *
                 phase[i].second.d * phase[i].second.t;
      if(L < phase[i].second.t) {
        var l = L;
        var r = phase[i].second.t - 1;
        Chmin(r, R);
        //l + (l + 1) + .. + r
        contrib += sum(l, r) * phase[i].second.d;
      }
      ans += contrib;
    }
    return ans >= H;
  };
  //checker(1);
  var ans = FirstTrue<i64>(0, 1e18, checker);
  out << *ans;
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  //in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}