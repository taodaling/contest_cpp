#pragma once
#include "common.cpp"
using namespace dalt;
#include "factorize.cpp"
#include "math.cpp"
void SolveOne(int test_id, IStream &in, OStream &out) {
  int N, Q;
  in >> N >> Q;
  Vec<i64> A(N);
  in >> A;
  var factors = Factorize(N);
  int K = Size(factors);
  Debug(factors);
  Vec<Vec<i64>> sum(K);
  Vec<MultiTreeSet<i64>> sets(K);
  for(int i = 0; i < K; i++) {
    int factor = factors[i];
    int step = N / factor;
    sum[i] = Vec<i64>(step);
    for(int j = 0; j < step; j++) {
      for(int k = j; k < N; k += step) {
        sum[i][j] += A[k];
      }
      sets[i].insert(sum[i][j]);
    }
  }
  Debug(sets);
  var answer = [&]() {
    Debug(A);
    Debug(sets);
    i64 best = 0;
    for(int i = 0; i < K; i++) {
      Chmax(best, (*sets[i].rbegin()) * (N / factors[i])); 
    }
    out << best << '\n';
  };
  answer();
  for(int i = 0; i < Q; i++) {
    int index;
    i64 x;
    in >> index >> x;
    index--;
    for(int j = 0; j < K; j++) {
      int factor = factors[j];
      int step = N / factor;
      int id = index % step;
      sets[j].erase(sets[j].lower_bound(sum[j][id]));
      sum[j][id] -= A[index];
      sum[j][id] += x;
      sets[j].insert(sum[j][id]);
    }
    A[index] = x;
    answer();
  }
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}
