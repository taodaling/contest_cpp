#pragma once
#include "common.cpp"
using namespace dalt;
#include "modint.cpp"
#include "euclid_like_function.cpp"
#include "generic_log.cpp"

using DM = DynamicModular<>;
using Mi = ModInt<DM>;
void SolveOne(int test_id, IStream &in, OStream &out) {
  int P, A, B, S, G;
  in >> P >> A >> B >> S >> G;
  DM::Register(P); 
  if(S == G) {
    out << 0 << '\n';
    return;
  }
  if(Mi(A) * Mi(S) + Mi(B) == Mi(G)) {
    out << 1 << '\n';
    return;
  }
  if(A == 0) {
    if(B == G) {
      out << 1 << '\n';
    } else {
      out << -1 << '\n';
    }
    return;
  }
  if(A == 1) {
    if(B == 0) {
      out << -1 << '\n';
    } else {
      out << (Mi(G) - Mi(S)) / Mi(B) << '\n';
    }
    return;
  }
  if(Mi(A) * Mi(S) - Mi(S) + Mi(B) == Mi(0)) {
    out << -1 << '\n';
    return;
  }
  math::CoprimeModLog<Mi> loger(A);
  Mi right = (Mi(G) * Mi(A - 1) + Mi(B)) / (Mi(A) * Mi(S) - Mi(S) + Mi(B));
  var ans = loger.log(right);
  if(ans.is_none()) {
    out << -1 << '\n';
  } else {
    out << *ans << '\n';
  }
}

void SolveMulti(IStream &in, OStream &out) {
  //std::ifstream input("in");
  int num_of_input = 1;
  in >> num_of_input;
  for (int i = 0; i < num_of_input; i++) {
    //SolveOne(i + 1, input, out);
	SolveOne(i + 1, in, out);
  }
}